---
layout: post
title: 'MXNet 数据操作'
subtitle: 'MXNet 数据操作'
description: 'MXNet 数据操作 篇'
date: 2019-02-03
lastmod: 2019-02-13
categories: 技术
tags: 《动手学深度学习》 机器学习
---
# MXNet 数据操作

## 1. NDArray 介绍

附上 [MXNet-NDArray Python 文档](https://mxnet.apache.org/api/python/ndarray/ndarray.html) 。

**NDArray** 是 MXNet 中用来存储和变换数据的主要工具，其用法与 `numpy.ndarray` 极其类似，但是 `NDArray` 提供了 *GPU计算* 和 *自动求梯度* 等更多功能。

>备忘录：
>
>在使用 *reshape()* 函数时，若使用 -1，则 NDArray 会自动根据元素个数和其他维度信息进行推理，无需写明。
>
>如 nd.arange(8).reshape((-1, 2))，此时 -1 将会被推理为 4。



## 2. 运算

在 `NDArray` 中，默认的 *加减乘除* 是 *逐元素* 进行的，如果需要进行 *点乘* 则需要使用 `nd.dot()` 函数进行。

另外 `NDArray` 还支持 **互相比较**，此方法会 **逐元素** 进行比较，因此必须保证两个 `NDArray` 的 shape 相同。

矩阵乘法：

~~~python
a = nd.arange(6).reshape((2, 3))
b = nd.arange(6).reshape((3, 2))
a, b
~~~

>(
>
>[[0. 1. 2.]
>
>[3. 4. 5.]]
>
><NDArray 2x3 @cpu(0)>, 
>
>[[0. 1.]
>
>[2. 3.]
>
>[4. 5.]]
>
><NDArray 3x2 @cpu(0)>)

~~~python
nd.dot(a, b)
~~~

>[[10. 13.]
>
>[28. 40.]]
>
><NDArray 2x2 @cpu(0)>



## 3. 广播机制

`NDArray` 允许对两个形状不同的矩阵进行 **按元素计算**。当两个矩阵形状不同时，`NDArray` 会触发 **广播机制**：即先适当复制元素，使两个矩阵形状相同，再进行计算。

在这里，我发现 *广播机制* 只存在以下3种 *扩充* 方式，即：

1. 只有在 **n行1列** 的矩阵上可以进行 **列扩充**；
2. 只有在 **1行n列** 的矩阵上可以进行 **行扩充**。
3. 当矩阵只有 **1个元素** 时，可以进行 **任意扩充**。

例：

~~~python
A = nd.arange(8).reshape((4, 1))
A
~~~

>[[0.]
>
>[1.]
>
>[2.]
>
>[3.]]
>
><NDArray 4x1 @cpu(0)>

```python
B = nd.arange(4).reshape((1, 4))
B
```

>[[0. 1. 2. 3.]]
>
><NDArray 4x1 @cpu(0)>

~~~python
A * B
~~~

>[[0. 0. 0. 0.]
>
>[0. 1. 2. 3.]
>
>[0. 2. 4. 6.]
>
>[0. 3. 6. 9.]]
>
><NDArray 4x4 @cpu(0)>

此处首先执行的是 *将 A 的第 1 列元素被广播到第 2~4 列* ，并且 *将 B 的第 1 行元素被广播到第 2~4 行*，再对广播后的形状相同的元素进行相乘，最终得出结果。

而当 A 为2列4行时，A无法被广播，同样的，当 B 为2行4列时，B也无法被广播。



## 4. 索引

原先是不算写索引总结的，结果在实验的时候试出了一些以前没遇到过的方式（表格中后两行），在此总结一下。

`NDArray` 索引方式与 Numpy 类似，以下表格写出了常用的索引方式：

|                 写法                  |                          值                          |
| :-----------------------------------: | :--------------------------------------------------: |
|                   X                   | [[ 2. 3. 8. 9.] [12. 12. 12. 12.] [20. 21. 22. 23.]] |
|                 X[0]                  |                    [2. 3. 8. 9.]                     |
|                 X[:1]                 |                   [[2. 3. 8. 9.]]                    |
|                X[:, 0]                |                    [ 2. 12. 20.]                     |
|               X[:, :1]                |                 [[ 2.] [12.] [20.]]                  |
|               X[[0, 2]]               |        [[ 2.  3.  8.  9.] [20. 21. 22. 23.]]         |
|             X[[0, 2], 0]              |                      [ 2. 20.]                       |
|             X[[0, 2], :1]             |                    [[ 2.] [20.]]                     |
|           X[[0, 2], [0, 2]]           |                      [ 2. 22.]                       |
| X[[[0, 2], [1, 2]], [[0, 2], [1, 3]]] |                [[ 2. 22.] [12. 23.]]                 |

最后两种索引方式可以将前面部分看做x坐标，将后面部分看做y坐标，并且每个都是一一对应关系，并且最后一种方式似乎可以无限嵌套，只要前后都有一一对应即可。



## 5. 内存管理

在对 `NDArray` 进行运算时，了解其内存的工作方式尤为重要，否则可能在编写代码时会出现出人意料的问题，因此在这里总结一下用法和内存变化的方式。

|           计算公式           | id(X) | id(Y) | id(Z) |
| :--------------------------: | :---: | :---: | :---: |
|          Y = Y + X           |   /   | 变化  |   /   |
|         Z[:] = X + Y         |   /   |   /   |   /   |
| nd.elemwise_add(X, Y, out=Z) |   /   |   /   |   /   |
|            X += Y            |   /   |   /   |   /   |
|         X[:] = X + Y         |   /   |   /   |   /   |

